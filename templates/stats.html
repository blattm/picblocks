<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Malpedia BlocksDB</title>
    <!-- CSS only -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-+0n0xVW2eSR5OomGNYDnhzAbDsOXxcvSN1TPprVMTNDbiYZCxYbOOl7+AMvyTG2x"
      crossorigin="anonymous"
    />
    <link rel="stylesheet" href="/static/css/styles.css" />
    <!-- Libraries -->

    <!-- DATA IMPORT FOR TESTING REMOVE IN PRODUCTION -->
    <script type="text/javascript" src="/static/js/s_stats.js"></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.5.1/chart.min.js"
      integrity="sha512-Wt1bJGtlnMtGP0dqNFH1xlkLBNpEodaiQ8ZN5JLA5wpc1sUlk/O5uuOMNgvzddzkpvZ9GLyYNa8w2s7rqiTk5Q=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <script
      src="https://code.jquery.com/jquery-3.6.0.min.js"
      integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4="
      crossorigin="anonymous"
    ></script>
  </head>
  <body>
    <!-- Navbar -->
    <nav
      class="
        py-3
        navbar navbar-expand-lg
        fixed-top
        auto-hiding-navbar
        navbar-light
        bg-light
      "
    >
      <div class="container">
        <a class="navbar-brand" href="#">Malpedia BlocksDB</a>
        <button
          class="navbar-toggler"
          type="button"
          data-bs-toggle="collapse"
          data-bs-target="#navbarSupportedContent"
          aria-controls="navbarSupportedContent"
          aria-expanded="false"
          aria-label="Toggle navigation"
        >
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
          <ul class="navbar-nav ms-auto">
            <li class="nav-item">
              <a class="nav-link active" aria-current="page" href="/">Home</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="/about">About</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="/stats">Statistics</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="/contact">Contact</a>
            </li>
          </ul>
        </div>
      </div>
    </nav>
    <!-- Navbar End -->

    <!-- Hero section -->
    <section id="hero" style="margin-top: 100px">
      <div class="container">
        <div class="row">
          <div class="col">
            <p></p>
            <!--
       <table class="table">
	       <tr>
		       <th class="not_mapped_style" style="text-align:left">Database: </th>
		       <td>{{db_online}}</td>
	       </tr>
	       <tr>
		       <th class="not_mapped_style" style="text-align:left">Tracked Families: </th>
		       <td>{{tracked_families}}</td>
	       </tr>
	       <tr>
		       <th class="not_mapped_style" style="text-align:left">Number of Samples: </th>
		       <td>{{number_samples}}</td>
	       </tr>
	       <tr>
		       <th class="not_mapped_style" style="text-align:left">Number of Blockhashes: </th>
		       <td>{{number_blocks}}</td>
	       </tr>
       </table>
            -->

            <!-- {{s_stats}} -->
          </div>
        </div>
        <div class="row">
          <div class="col">
            <!--Istogramma di tutte le famiglie verificate ( key() ) -->
            <h3>Verified families</h3>
            <canvas
              id="topVerifiedFamiliesChart"
              width="400"
              height="400"
            ></canvas>
            <!--
              Il numero di famiglie verificate che non sono state individuate
              (ovvero se nel item() di key() non c'e' il valore key() con
              frequenza almeno TOP5 ), numero assoluto e percentuale sul totale
              delle famiglie verificate

              Il numero di famiglie verificate che sono state individuate (il
              contrario di quello sopra), numero assoluto e percentuale sul
              totale delle familgie verificate

              [DB] se uso un quartile o comuqnue un valore TOPX ovviamente la
              percentuale sarà sempre fissa. Per questo uso media e dev std
              per calcolare il cutoff (visto che la distribuzione non è normale
              ci potrebbe essere qualcosa di particolare)
            -->
            <ul>
              <li>
                <b>Verified families count:</b> <span id="totalFamilies"></span>
              </li>
              <li>
                <b>Identified families count:</b>
                <span id="totalIdentified"></span>
              </li>
              <li>
                <b>Unidentified families count:</b>
                <span id="totalUnidentified"></span>
              </li>
            </ul>
            <!-- Le famiglie senza detection -->
            <h3>Families without detections</h3>
            <div class="row">
              <div class="col">
                <ul id="familiesWithoutDetections1"></ul>
              </div>
              <div class="col">
                <ul id="familiesWithoutDetections2"></ul>
              </div>
              <div class="col">
                <ul id="familiesWithoutDetections3"></ul>
              </div>
            </div>
            <nav>
              <ul id="familiesWithoutDetectionsPagination"></ul>
            </nav>

            <!--
                Istogramma che le principali famiglie riconosciute (non verificate,
                quindi di tutti gli elementi di ogni array per ogni famiglia
                verificata)
            -->
            <h3>Top detected families</h3>
            <canvas
              id="topDetectedFamiliesChart"
              width="400"
              height="400"
            ></canvas>

            <!--
                Le famiglie verificate che sono piu singolari, ovvero che non
                condividono codice con altre famiglie (ovvero quelle che hanno
                bassa soglia di somiglianza)
            -->
            <h3>
              Peculiar families
              <small>(families with less code resemblance)</small>
            </h3>
            <div class="row">
              <div class="col">
                <ul id="peculiarFamilies1"></ul>
              </div>
              <div class="col">
                <ul id="peculiarFamilies2"></ul>
              </div>
              <div class="col">
                <ul id="peculiarFamilies3"></ul>
              </div>
            </div>
            <nav>
              <ul id="peculiarFamiliesPagination"></ul>
            </nav>

            <!--
                Le famiglie verificate che piu si assomigliano (che condividono
                le stesse attriuzioni con frequenza TOP5) pensare magare ad un
                grafico a cluster o a palle... vedi tu quello che meglio si
                addice
            -->
            <h3>Families similarities</h3>
            <div class="row">
              <div class="col">
                <select
                  id="familiesSelector"
                  name="Family"
                  onchange="if (this.selectedIndex >= 0) drawFamilySimilarity(this[this.selectedIndex].value);"
                ></select>
              </div>
            </div>
            <div class="row">
              <div class="col">
                <canvas id="familySimilarity" width="400" height="400"></canvas>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
    <script type="text/javascript">
      const colorOptions = {
        backgroundColor: [
          'rgba(255, 99, 132, 0.2)',
          'rgba(255, 159, 64, 0.2)',
          'rgba(255, 205, 86, 0.2)',
          'rgba(75, 192, 192, 0.2)',
          'rgba(54, 162, 235, 0.2)',
          'rgba(153, 102, 255, 0.2)',
          'rgba(201, 203, 207, 0.2)',
        ],
        borderColor: [
          'rgb(255, 99, 132)',
          'rgb(255, 159, 64)',
          'rgb(255, 205, 86)',
          'rgb(75, 192, 192)',
          'rgb(54, 162, 235)',
          'rgb(153, 102, 255)',
          'rgb(201, 203, 207)',
        ],
        borderWidth: 1,
      };

      function topVerifiedFamilies(sStat, top = 30) {
        const entries = Object.entries(sStat.family_verified_frequency)
          .sort(
            (a, b) =>
              // a[0].localeCompare(b[0])
              b[1] - a[1]
          )
          .slice(0, top);
        const data = {
          labels: [],
          datasets: [
            {
              label: 'Verified families',
              data: [],
              ...colorOptions,
            },
          ],
        };
        for (const ent of entries) {
          data.labels.push(ent[0]);
          data.datasets[0].data.push(ent[1]);
        }
        return {
          type: 'bar',
          data,
          options: {
            scales: {
              y: {
                beginAtZero: true,
              },
            },
          },
        };
      }

      function identifiedVsUnidentified(sStat, sigma = 1) {
        let mean = 0;
        let devStd = 0;
        const values = Object.values(sStat.family_verified_frequency);
        for (const val of values) {
          mean += val;
        }
        mean = mean / values.length;
        for (const val of values) {
          devStd += Math.pow(val - mean, 2);
        }
        devStd = Math.sqrt(devStd / (values.length - 1));
        const cutoff = mean + sigma * devStd;
        const result = {
          total: values.length,
          identified: 0,
          unidentified: 0,
        };

        for (const el of values) {
          if (el >= cutoff) {
            result.identified += 1;
          } else {
            result.unidentified += 1;
          }
        }
        return result;
      }

      function familiesWithoutDetection(sStat) {
        const families = {...sStat.family_verified_frequency};
        for (const [family, detections] of Object.entries(
          sStat.family_verified_vs_detected
        )) {
          if (family in detections) {
            delete families[family];
          }
        }
        return Object.keys(families).sort();
      }

      function topDetectedFamilies(sStat, top = 30) {
        const tops = {};
        for (const detections of Object.values(
          sStat.family_verified_vs_detected
        )) {
          for (const [family, count] of Object.entries(detections)) {
            tops[family] = (tops[family] || 0) + count;
          }
        }
        const data = {
          labels: [],
          datasets: [
            {
              label: 'Detected families',
              data: [],
              ...colorOptions,
            },
          ],
        };
        for (const el of Object.entries(tops)
          .sort((a, b) => b[1] - a[1])
          .slice(0, top)) {
          data.labels.push(el[0]);
          data.datasets[0].data.push(el[1]);
        }
        return {
          type: 'bar',
          data,
          options: {
            scales: {
              y: {
                beginAtZero: true,
              },
            },
          },
        };
      }

      function getSimilarAndPeculiarFamilies(sStat) {
        const sortedFamilies = Object.keys(
          sStat.family_verified_vs_detected
        ).sort((a, b) => a.localeCompare(b));
        const peculiar = [];
        const similar = [];
        for (const fam of sortedFamilies) {
          const ss = Object.keys(sStat.family_verified_vs_detected[fam]).length;
          if (ss === 0) {
            continue;
          } else if (ss === 1) {
            peculiar.push(fam);
          } else {
            similar.push(fam);
          }
        }
        return {peculiar, similar};
      }

      function getSimilar(sStat, family) {
        const config = {
          type: 'polarArea',
          data: {
            labels: [],
            datasets: [
              {
                label: `Detection for ${family}`,
                data: [],
                ...colorOptions,
              },
            ],
          },
        };
        for (const [fam, val] of Object.entries(
          sStat.family_verified_vs_detected[family]
        )) {
          config.data.labels.push(fam);
          config.data.datasets[0].data.push(val);
        }
        return config;
      }

      let similarChart;
      function drawFamilySimilarity(family) {
        if (similarChart) {
          similarChart.destroy();
        }
        similarChart = new Chart(
          document.getElementById('familySimilarity'),
          getSimilar(s_stats[0], family)
        );
      }

      const c1 = new Chart(
        document.getElementById('topVerifiedFamiliesChart'),
        topVerifiedFamilies(s_stats[0])
      );
      const idUnid = identifiedVsUnidentified(s_stats[0]);
      $('#totalFamilies').text(`${idUnid.total}`);
      $('#totalIdentified').text(
        `${idUnid.identified} (${
          Math.round((idUnid.identified / idUnid.total) * 10000) / 100
        }%)`
      );
      $('#totalUnidentified').text(
        `${idUnid.unidentified} (${
          Math.round((idUnid.unidentified / idUnid.total) * 10000) / 100
        }%)`
      );

      function createPagination(elements, pagId, listId) {
        $(`#${pagId}`).addClass('pagination');
        let selectedPage = 0;
        const GROUPS = 3;
        const SIZE = 10;
        for (
          let idx = 0;
          idx < Math.ceil(elements.length / (GROUPS * SIZE));
          idx++
        ) {
          $(`#${pagId}`).append(
            $(
              `<li class="page-item" id="${pagId}${idx}"><a class="page-link" href="#">${
                idx + 1
              }</a></li>`
            )
          );
        }
        const selectPage = (page) => {
          $(`li#${pagId}${selectedPage}`).removeClass('active');
          $(`li#${pagId}${page}`).addClass('active');
          selectedPage = page;
          for (let group = 0; group < GROUPS; group++) {
            $(`#${listId}${group + 1} li`).remove();
            for (const fam of elements.slice(
              (selectedPage + group) * 10,
              (selectedPage + group) * 10 + 10
            )) {
              $(`#${listId}${group + 1}`).append($(`<li>${fam}</li>`));
            }
          }
        };
        $(`ul#${pagId} li a`).on('click', function (e) {
          e.preventDefault();
          const tag = $(this);
          const page = parseInt(tag.text()) - 1;
          if (selectedPage !== page) {
            selectPage(page);
          }
        });
        selectPage(0);
      }

      createPagination(
        familiesWithoutDetection(s_stats[0]),
        'familiesWithoutDetectionsPagination',
        'familiesWithoutDetections'
      );

      const c2 = new Chart(
        document.getElementById('topDetectedFamiliesChart'),
        topDetectedFamilies(s_stats[0])
      );

      const {peculiar, similar} = getSimilarAndPeculiarFamilies(s_stats[0]);
      createPagination(
        peculiar,
        'peculiarFamiliesPagination',
        'peculiarFamilies'
      );
      for (const fam of similar) {
        $('#familiesSelector').append(
          $(
            `<option value="${fam}">${fam} (${
              Object.keys(s_stats[0].family_verified_vs_detected[fam]).length
            })</option>`
          )
        );
      }
      drawFamilySimilarity(similar[0]);
    </script>
  </body>
</html>
